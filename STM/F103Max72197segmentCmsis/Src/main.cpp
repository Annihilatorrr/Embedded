/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include "display7segmentmax7219.h"
#include "spi.h"
#include "delay.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int clockInit(void)

{
	// RCC - reset and clock control, CR - Clock control register
	SET_BIT(RCC->CR, RCC_CR_HSEON); //Enable HSE clock

	while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET); //wait until HSE ready

	//Configuring of PLL (HSE crystal frequency is 8MHz)
	// SYSCLK = 72 МГц, USB = 48 МГц, PCLK1 = 36 МГц, PCLK2 = 72 МГц,  ADC = 12 МГц
	RCC->CFGR |= RCC_CFGR_PLLMULL9 //Bits 21:18, 0111: PLL input clock x 9
			| RCC_CFGR_PLLSRC; //Enable PLL as a source of HSE

	RCC->CR |= RCC_CR_PLLON; //Run PLL

	while(!(RCC->CR & RCC_CR_PLLRDY));
	CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// 2 cycles of Flash wait because 48 MHz < SYSCLK ≤ 72 MHz
	FLASH->ACR &= ~FLASH_ACR_LATENCY_2;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1 //APB2/1
			| RCC_CFGR_PPRE1_DIV2 //APB1/2
			| RCC_CFGR_HPRE_DIV1; //AHB/1

	RCC->CFGR |= RCC_CFGR_SW_PLL;

	while((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_1);

	RCC->CR &= ~RCC_CR_HSION;

	return 0;
}

void spi1_init(void)
{
	auto reg = GPIOA->CRL;
	reg &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4 | GPIO_CRL_CNF5 | GPIO_CRL_MODE5 | GPIO_CRL_CNF6 | GPIO_CRL_MODE6 | GPIO_CRL_CNF7 | GPIO_CRL_MODE7);
	GPIOA->CRL = reg;

	GPIOA->CRL   |=  GPIO_CRL_MODE7;  // output 50 MHz
	GPIOA->CRL   &= ~GPIO_CRL_CNF7;	  // Push-Pull
	GPIOA->CRL   |=  GPIO_CRL_CNF7_1; // alternative function push-pull

	GPIOA->CRL   &= ~GPIO_CRL_MODE6;  // Input
	GPIOA->CRL   |=  GPIO_CRL_CNF6_1; // with pull-up / pull-down
	GPIOA->BSRR   =  GPIO_BSRR_BS6;   // Set bit 6 High

	GPIOA->CRL   |=  GPIO_CRL_MODE5;  // output 50 MHz
	GPIOA->CRL   |=  GPIO_CRL_CNF5_1; // alternative function push-pull

	GPIOA->CRL   |=  GPIO_CRL_MODE4;  // output 50 MHz
	GPIOA->CRL   &= ~GPIO_CRL_CNF4;	  // Push-Pull General Purpose
	GPIOA->BSRR   =  GPIO_BSRR_BS4;   // Set bit 4 High

	SPI1->CR1 = 0x0000; // reset SPI configuration registers
	SPI1->CR2 = 0x0000; // reset SPI configuration registers

	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN; // enable spi clock
	SPI1->CR1   &= ~SPI_CR1_SPE; // disable SPI before configuring
	SPI1->CR1 = 0 << SPI_CR1_DFF_Pos    // 8 bit Data frame format
			| 0 << SPI_CR1_LSBFIRST_Pos //  MSB transferred first
			| SPI_CR1_SSM               //Software SS
			| SPI_CR1_SSI               // NSS (CS) pin is high
			| SPI_CR1_BR_0 | SPI_CR1_BR_1  //Baud: F_PCLK/16
			| SPI_CR1_MSTR // Master mode
			| 0 << SPI_CR1_CPOL_Pos // Clock polarity
			| 0 << SPI_CR1_CPHA_Pos;  // Clock phase

	SPI1->CR1 |= SPI_CR1_SPE; // Enable SPI
}

void spi2_init(void)
{
	GPIOB->CRH &= ~(GPIO_CRH_CNF12 | GPIO_CRH_MODE12 | GPIO_CRH_CNF13 | GPIO_CRH_MODE13 | GPIO_CRH_CNF14 | GPIO_CRH_MODE14 | GPIO_CRH_CNF15 | GPIO_CRH_MODE15);

	GPIOB->CRH   |=  GPIO_CRH_MODE15;  // output 50 MHz (11)
	GPIOB->CRH   &= ~GPIO_CRH_CNF15;   // Push-Pull (00)
	GPIOB->CRH   |=  GPIO_CRH_CNF15_1; // alternative function push-pull (10)

	GPIOB->CRH   &= ~GPIO_CRH_MODE14;  // Input (00)
	GPIOB->CRH   |=  GPIO_CRH_CNF14_1; // with pull-up / pull-down
	GPIOB->BSRR   =  GPIO_BSRR_BS14;   // Set bit 14 High

	GPIOB->CRH   |=  GPIO_CRH_MODE13;  // output 50 MHz
	GPIOB->CRH   |=  GPIO_CRH_CNF13_1; // alternative function push-pull

	GPIOB->CRH   |=  GPIO_CRH_MODE12;  // output 50 MHz
	GPIOB->CRH   &= ~GPIO_CRH_CNF12;	  // Push-Pull General Purpose
	GPIOB->BSRR   =  GPIO_BSRR_BS12;   // Set bit 12 High

	SPI2->CR1 = 0x0000; // reset SPI configuration registers
	SPI2->CR2 = 0x0000; // reset SPI configuration registers

	RCC->APB1ENR |= RCC_APB1ENR_SPI2EN; // enable spi clock

	SPI2->CR1 &= ~SPI_CR1_SPE; // disable SPI before configuring
	SPI2->CR1 = 0 << SPI_CR1_DFF_Pos    // 8 bit Data frame format
			| 0 << SPI_CR1_LSBFIRST_Pos //  MSB transferred first
			| SPI_CR1_SSM               //Software SS
			| SPI_CR1_SSI               // NSS (CS) pin is high
			| SPI_CR1_BR_0 | SPI_CR1_BR_1  //Baud: F_PCLK/16
			| SPI_CR1_MSTR // Master mode
			| 0 << SPI_CR1_CPOL_Pos // Clock polarity
			| 0 << SPI_CR1_CPHA_Pos  // Clock phase
			| SPI_CR1_SPE; // Enable SPI
}

//void initPortAClock()
//{
//	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
//}
//
//void initPortBClock()
//{
//	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
//}
//void initDmaClock()
//{
//	RCC->AHBENR |= RCC_AHBENR_DMA1EN;
//}
void initSwdOnlyDebugging()
{
	AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE; // JTAG is disabled
}
//void initAltFunctionsClock()
//{
//	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
//}

int main(void)
{
	clockInit();
	SysTick_Init(72000000);
	initSwdOnlyDebugging();

	SpiF103 spi1(SpiF103::Spi1, SpiF103::SpiFrameSize::Bit16);
	Display7segmentMax7219<Controller::f103> display1(&spi1);

	display1.init(15, 8);
	display1.print(-82212);

	for(int i = 0;i <= 100;++i)
	{
		display1.clean();
		display1.print(i);
		delayMs(10);
	}

	SpiF103 spi2(SpiF103::Spi2, SpiF103::SpiFrameSize::Bit8);
	Display7segmentMax7219<Controller::f103> display2(&spi2);
	display2.init(15, 8);
	display2.print(-82212);

	for(int i = 101;i <= 200;++i)
	{
		display2.clean();
		display2.print(i);
		delayMs(10);
	}
}
