/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "display7segmentmax7219.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define PLL_M  16
#define PLL_N  336
#define PLL_P   2
#define PLL_Q   7

int ClockInit(void)
{
	__IO int StartUpCounter;

	//ЗАПУСК КВАРЦЕВОГО ГЕНЕРАТОРА:

	RCC->CR |= (1<<RCC_CR_HSEON_Pos); //Запускаем генератор HSE

	//Ждем успешного запуска или окончания тайм-аута
	for(StartUpCounter = 0; ; StartUpCounter++)
	{
		//Если успешно запустилось, то выходим из цикла
		if(RCC->CR & (1<<RCC_CR_HSERDY_Pos)) break;

		//Если не запустилось, то отключаем все, что включили
		if(StartUpCounter > 0x1000) RCC->CR &= ~(1<<RCC_CR_HSEON_Pos);
	}

	//НАСТРОЙКА И ЗАПУСК PLL:
	//Частота кварца 8 MHz
	//f_{PLL general clock output} = [(HSE_VALUE/PLLM)*PLLN]/PLLP

	//Устанавливаем PLLM = 8 <---> (00 1000)
	RCC->PLLCFGR |= (RCC_PLLCFGR_PLLM_3);
	RCC->PLLCFGR &= ~(RCC_PLLCFGR_PLLM_1 | RCC_PLLCFGR_PLLM_2 | RCC_PLLCFGR_PLLM_5 | RCC_PLLCFGR_PLLM_0 | RCC_PLLCFGR_PLLM_4);

	//Устанавливаем PLLN = 144 <---> (0 1001 0000)
	RCC->PLLCFGR |= (RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_7);
	RCC->PLLCFGR &= ~(RCC_PLLCFGR_PLLN_0 | RCC_PLLCFGR_PLLN_1 | RCC_PLLCFGR_PLLN_2 | RCC_PLLCFGR_PLLN_3 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_8);

	//Устанавливаем PLLP = 2 <---> (00)
	RCC->PLLCFGR &= ~(RCC_PLLCFGR_PLLP_0 | RCC_PLLCFGR_PLLP_1);

	RCC->PLLCFGR |= (1<<RCC_PLLCFGR_PLLSRC_Pos);   //Тактирование PLL от HSE

	RCC->CR |= (1<<RCC_CR_PLLON_Pos);              //Запускаем PLL

	//Ждем успешного запуска или окончания тайм-аута
	for(StartUpCounter = 0; ; StartUpCounter++)
	{
		if(RCC->CR & (1<<RCC_CR_PLLRDY_Pos)) break;

		if(StartUpCounter > 0x1000)
		{
			RCC->CR &= ~(1<<RCC_CR_HSEON_Pos);
			RCC->CR &= ~(1<<RCC_CR_PLLON_Pos);
		}
	}

	// НАСТРОЙКА FLASH И ДЕЛИТЕЛЕЙ:

	//Устанавливаем 2 цикла ожидания для Flash
	FLASH->ACR |= (0x02<<FLASH_ACR_LATENCY_Pos);

	RCC->CFGR |= (0x00<<RCC_CFGR_PPRE2_Pos) //Делитель шины APB2 равен 1
		| (0x04<<RCC_CFGR_PPRE1_Pos)        //Делитель шины APB1 равен 2
		| (0x00<<RCC_CFGR_HPRE_Pos);        //Делитель AHB равен 1


	RCC->CFGR |= (0x02<<RCC_CFGR_SW_Pos);   //Переключаемся на работу от PLL

	//Ждем, пока переключимся
	while((RCC->CFGR & RCC_CFGR_SWS_Msk) != (0x02<<RCC_CFGR_SWS_Pos)){ }

	//После того, как переключились на внешний источник такирования отключаем внутренний RC-генератор (HSI) для экономии энергии
	RCC->CR &= ~(1<<RCC_CR_HSION_Pos);

	return 0;
}
int main(void)
{
	ClockInit();

	SpiF401 spi1(SpiF401::SpiNumber::Spi1, SpiF401::SpiFrameSize::Bit8);
	SpiF401 spi3(SpiF401::SpiNumber::Spi3, SpiF401::SpiFrameSize::Bit8);

	Display7segmentMax7219<Controller::f401> display1(&spi1);
	display1.init(15, 8);
	display1.print(987);

	Display7segmentMax7219<Controller::f401> display2(&spi3);
	display2.init(15, 8);
	display2.print(432);
	/* Loop forever */
	for(;;);
}
