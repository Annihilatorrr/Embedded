/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "stm32f1xx.h"
#include "spi.h"
#include "uart.h"
#include "rc522.h"
#include "delay.h"
#include "mfrc522.h"
#include "display7segmentmax7219.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint32_t ReceiveData;
extern "C" void USART1_IRQHandler(void)
{
	if (USART1->SR & USART_SR_RXNE) // функция-обработчик события «принят байт данных»
	{
		USART1->SR &= ~USART_SR_RXNE; //очищаем флаг события
		ReceiveData = USART1->DR; //сохраняем значение байта в глобальную переменную
		USART1->DR = ReceiveData; //отправляем полученное значение обратно
	}
	if (USART1->SR & USART_SR_TXE) //функция-обработчик события «началась отправка байта данных»
	{
		USART1->SR &= ~USART_SR_TXE; //очищаем флаг события
	}
	if (USART1->SR & USART_SR_TC) // функция-обработчик события «завершилась отправка байта данных»
	{
		USART1->SR &= ~USART_SR_TC; //очищаем флаг события
	}
}

void initPortCClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

	GPIOC->CRH &= ~GPIO_CRH_CNF13;
	GPIOC->CRH |= GPIO_CRH_MODE13_1;

	GPIOC->CRH &= ~GPIO_CRH_CNF14;
	GPIOC->CRH |= GPIO_CRH_MODE14_1;
}

void enablePortAClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
}

int clockInit(void)

{
	// RCC - reset and clock control, CR - Clock control register
	SET_BIT(RCC->CR, RCC_CR_HSEON); //Enable HSE clock

	while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET); //wait until HSE ready

	//Configuring of PLL (HSE crystal frequency is 8MHz)
	// SYSCLK = 72 МГц, USB = 48 МГц, PCLK1 = 36 МГц, PCLK2 = 72 МГц,  ADC = 12 МГц
	RCC->CFGR |= RCC_CFGR_PLLMULL9 //Bits 21:18, 0111: PLL input clock x 9
			| RCC_CFGR_PLLSRC; //Enable PLL as a source of HSE

	RCC->CR |= RCC_CR_PLLON; //Run PLL

	while(!(RCC->CR & RCC_CR_PLLRDY));
	CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// 2 cycles of Flash wait because 48 MHz < SYSCLK ≤ 72 MHz
	FLASH->ACR &= ~FLASH_ACR_LATENCY_2;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1 //APB2/1
			| RCC_CFGR_PPRE1_DIV2 //APB1/2
			| RCC_CFGR_HPRE_DIV1; //AHB/1

	RCC->CFGR |= RCC_CFGR_SW_PLL;

	while((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_1);

	RCC->CR &= ~RCC_CR_HSION;

	return 0;
}

void enableUart()
{
	uint32_t baudRate = 115200;
	uint32_t usartClock = 72000000;

	enablePortAClock();

	// enable usart clock
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

	// enable AF clock
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;

	/* TX push-pull output, 50MHz */
	GPIOA->CRH &= ~GPIO_CRH_CNF9;   //Clear CNF9
	GPIOA->CRH |= GPIO_CRH_CNF9_1;  //Alternative function, push-pull as CNF9_0 = 0
	GPIOA->CRH |= GPIO_CRH_MODE9_1; //50 MHz

	/* RX HI-Z input*/
	GPIOA->CRH &= ~GPIO_CRH_CNF10;  //Clear CNF10
	GPIOA->CRH |= GPIO_CRH_CNF10_0; //HI_Z
	GPIOA->CRH &= ~GPIO_CRH_MODE10; //Clear MODE <=> INPUT

	USART1->BRR = (usartClock + baudRate/2)/baudRate;
	USART1->CR1 |= USART_CR1_UE | USART_CR1_TE | USART_CR1_RE |USART_CR1_RXNEIE|USART_CR1_TCIE;
	NVIC_EnableIRQ(USART1_IRQn);
}

void uartSendByte(char data)
{
	while(!(USART1->SR & USART_SR_TXE));
	USART1->DR=data;
}
void uartSendString(const char* str)
{
	const char *p = str;
	while(*p)
	{
		uartSendByte(*p);
		++p;
	}

}
void initSwdOnlyDebugging()
{
	AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE; // JTAG is disabled
}

// UART
#define 	WAIT_HEAD 		0
#define 	WAIT_TAIL 		1
#define 	CHEK_MSG 		2
#define 	TIME_OUT 		3
#define 	U1RXBUF_SIZE	255

uint8_t		uart1_rx_buf[U1RXBUF_SIZE];
uint8_t		uart1_rx_bit;
uint8_t		uart1_rx_status;
uint32_t	number;
uint8_t 	adress;
uint8_t 	value;

// RC522
uint8_t		cardstr[MFRC522_MAX_LEN+1];												// MFRC522_MAX_LEN = 16
uint8_t		lastID[4];

uint8_t status;
uint8_t card_data[17];
uint32_t delay_val = 1000; //ms
uint16_t result = 0;
uint8_t UID[5];

// a private key to scramble data writing/reading to/from RFID card:
u_char Mx1[7][5]={{0x12,0x45,0xF2,0xA8},{0xB2,0x6C,0x39,0x83},{0x55,0xE5,0xDA,0x18},
		{0x1F,0x09,0xCA,0x75},{0x99,0xA2,0x50,0xEC},{0x2C,0x88,0x7F,0x3D}};
u_char SectorKey[7];
int main(void)
{
	clockInit();
	SysTick_Init(72000000);
	enableUart();
	initSwdOnlyDebugging();
	__enable_irq();
	uartSendString("**************************************************\r\n");
	uartSendString("----- Example of communication with MFRC-522 -----\r\n");

	initSPI1();
	char str1[32]={'\0'};
	MFRC522 mfrc522;//(SS_PIN, RST_PIN);
	mfrc522.PCD_Init();
	uint8_t version = mfrc522.PCD_ReadRegister(MFRC522::PCD_Register::VersionReg);
	sprintf(str1,"Ver: %x\r\n", version);
	 (mfrc522.PICC_ReadCardSerial());
	{
		strcpy(str1, reinterpret_cast<const char*>(mfrc522.uid.uidByte));
		uartSendString(str1);
	}
	//
	//	Display7segmentMax7219 d(SPI1, GPIOA, 4);
	//	d.init(15, 8);
	//	d.print(-82212);

	MFRC522_Init();
	status = MFRC522_ReadRegister(MFRC522_REG_VERSION);

	sprintf(str1,"Running RC522 ");
	uartSendString(str1);

	char buf[64]{0};
	MFRC522_DumpVersionToSerial(status, buf);
	sprintf(str1,"ver: %s\r\n", buf);
	uartSendString(str1);
	while(1)
	{
		NVIC_DisableIRQ (USART1_IRQn);
		status = MFRC522_Request(PICC_REQIDL, cardstr);
		if (status == MI_OK)
		{
			sprintf(str1,"Card: %x %x %x\r\n", cardstr[0], cardstr[1], cardstr[2]);
			uartSendString(str1);
			status = MFRC522_Anticoll(cardstr);
			if (status == MI_OK)
			{
				sprintf(str1,"UID: %x %x %x %x\r\n", cardstr[0], cardstr[1], cardstr[2], cardstr[3]);
				uartSendString(str1);
				UID[0] = cardstr[0];
				UID[1] = cardstr[1];
				UID[2] = cardstr[2];
				UID[3] = cardstr[3];
				UID[4] = cardstr[4];
				delayMs(1);
				status = MFRC522_SelectTag(cardstr);
				if (status > 0)
				{
					SectorKey[0] = ((Mx1[0][0])^(UID[0])) + ((Mx1[0][1])^(UID[1])) + ((Mx1[0][2])^(UID[2])) + ((Mx1[0][3])^(UID[3]));// 0x11; //KeyA[0]
					SectorKey[1] = ((Mx1[1][0])^(UID[0])) + ((Mx1[1][1])^(UID[1])) + ((Mx1[1][2])^(UID[2])) + ((Mx1[1][3])^(UID[3]));// 0x11; //KeyA[0]
					SectorKey[2] = ((Mx1[2][0])^(UID[0])) + ((Mx1[2][1])^(UID[1])) + ((Mx1[2][2])^(UID[2])) + ((Mx1[2][3])^(UID[3]));// 0x11; //KeyA[0]
					SectorKey[3] = ((Mx1[3][0])^(UID[0])) + ((Mx1[3][1])^(UID[1])) + ((Mx1[3][2])^(UID[2])) + ((Mx1[3][3])^(UID[3]));// 0x11; //KeyA[0]
					SectorKey[4] = ((Mx1[4][0])^(UID[0])) + ((Mx1[4][1])^(UID[1])) + ((Mx1[4][2])^(UID[2])) + ((Mx1[4][3])^(UID[3]));// 0x11; //KeyA[0]
					SectorKey[5] = ((Mx1[5][0])^(UID[0])) + ((Mx1[5][1])^(UID[1])) + ((Mx1[5][2])^(UID[2])) + ((Mx1[5][3])^(UID[3]));// 0x11; //KeyA[0]
					delayMs(1);
					status = MFRC522_Auth(0x60, 3, SectorKey, cardstr);
					if (status == MI_OK)
					{
						result++;
						sprintf(str1, "Auth. OK");
						uartSendString(str1);
					}
					else
					{
						for (int i = 0; i < 16; i++) {cardstr[i] = 0;}
						status = 0;
						// Find cards
						delayMs(1);
						status = MFRC522_Request(PICC_REQIDL, cardstr);
						delayMs(1);
						status = MFRC522_Anticoll(cardstr);
						delayMs(1);
						status = MFRC522_SelectTag(cardstr);
						SectorKey[0] = 0xFF;
						SectorKey[1] = 0xFF;
						SectorKey[2] = 0xFF;
						SectorKey[3] = 0xFF;
						SectorKey[4] = 0xFF;
						SectorKey[5] = 0xFF;
						delayMs(1);
						status = MFRC522_Auth(0x60, 3, SectorKey, cardstr);
						if (status == MI_OK)
						{
						}
					}
				}
			}
			//MFRC522_StopCrypto1
			number = hex_to_char(0);
			//send_str("RC522 adress = ", 0);
			//SendNum(number, 1);
			adress = number;
			value = MFRC522_ReadRegister(adress);
			number = value;
			//send_str("REG value = ", 0);
			//SendNum(number, 2);
			uart1_rx_buf[0] = 0;
			uart1_rx_buf[1] = 0;
			NVIC_EnableIRQ (USART1_IRQn);

		}
		uartSendString("No RFID detected\r\n");

	}
	//    /* Loop forever */
	//	GPIOC->BSRR |= GPIO_BSRR_BS13; // pin C13 initially set
	//	GPIOC->BRR |= GPIO_BRR_BR14; // pin C14 initially reset, GPIOC->BSRR |= GPIO_BSRR_BR14 also works
	//	for(;;)
	//	{
	//		delayMs(500);
	//		GPIOC->ODR^=GPIO_ODR_ODR13;
	//		GPIOC->ODR^=GPIO_ODR_ODR14;
	//



	char str2[] = "wwwTesting... 0,1,2,3... ";
	uartSendString(str2);

}
