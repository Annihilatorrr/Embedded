/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include "stm32f1xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

volatile uint32_t sysTick = 0;
extern "C" void SysTick_Handler(void)
{
	if (sysTick > 0)
	{
		--sysTick;
	}
}
uint32_t ReceiveData;

extern "C" void USART1_IRQHandler(void)
{
	if (USART1->SR & USART_SR_RXNE) // функция-обработчик события «принят байт данных»
	{
		USART1->SR &= ~USART_SR_RXNE; //очищаем флаг события
		ReceiveData = USART1->DR; //сохраняем значение байта в глобальную переменную
		USART1->DR = ReceiveData; //отправляем полученное значение обратно
	}
	if (USART1->SR & USART_SR_TXE) //функция-обработчик события «началась отправка байта данных»
	{
		USART1->SR &= ~USART_SR_TXE; //очищаем флаг события
	}
	if (USART1->SR & USART_SR_TC) // функция-обработчик события «завершилась отправка байта данных»
	{
		USART1->SR &= ~USART_SR_TC; //очищаем флаг события
	}
}

void delayMs(uint32_t ms)
{
	sysTick = ms;
	while (sysTick);
}

void SysTick_Init(int cpuFrequency) {
	SysTick->LOAD &= ~SysTick_LOAD_RELOAD_Msk;
	SysTick->LOAD = cpuFrequency/1000-1;
	SysTick->VAL &= ~SysTick_VAL_CURRENT_Msk;
	SysTick->CTRL = (SysTick_CTRL_TICKINT_Msk   |  /* Enable SysTick exception */
			SysTick_CTRL_ENABLE_Msk) |    /* Enable SysTick system timer */
					SysTick_CTRL_CLKSOURCE_Msk;   /* Use processor clock source */

}

void initPortCClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

	GPIOC->CRH &= ~GPIO_CRH_CNF13;
	GPIOC->CRH |= GPIO_CRH_MODE13_1;

	GPIOC->CRH &= ~GPIO_CRH_CNF14;
	GPIOC->CRH |= GPIO_CRH_MODE14_1;
}
int clockInit(void)

{
	// RCC - reset and clock control, CR - Clock control register
	SET_BIT(RCC->CR, RCC_CR_HSEON); //Enable HSE clock

	while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET); //wait until HSE ready

	//Configuring of PLL (HSE crystal frequency is 8MHz)
	// SYSCLK = 72 МГц, USB = 48 МГц, PCLK1 = 36 МГц, PCLK2 = 72 МГц,  ADC = 12 МГц
	RCC->CFGR |= RCC_CFGR_PLLMULL9 //Bits 21:18, 0111: PLL input clock x 9
			| RCC_CFGR_PLLSRC; //Enable PLL as a source of HSE

	RCC->CR |= RCC_CR_PLLON; //Run PLL

	while(!(RCC->CR & RCC_CR_PLLRDY));
	CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// 2 cycles of Flash wait because 48 MHz < SYSCLK ≤ 72 MHz
	FLASH->ACR &= ~FLASH_ACR_LATENCY_2;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1 //APB2/1
			| RCC_CFGR_PPRE1_DIV2 //APB1/2
			| RCC_CFGR_HPRE_DIV1; //AHB/1

	RCC->CFGR |= RCC_CFGR_SW_PLL;

	while((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_1);

	RCC->CR &= ~RCC_CR_HSION;

	return 0;
}

void enableUart()
{
	uint32_t BaudRate = 115200;

	// enable port A clock
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;

	// enable usart clock
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

	// enable AF clock
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;

	/* TX push-pull output, 10MHz */
	GPIOA->CRH &= ~GPIO_CRH_CNF9;   //Clear CNF9
	GPIOA->CRH |= GPIO_CRH_CNF9_1;  //Alternative function, push-pull as CNF9_0 = 0
	GPIOA->CRH |= GPIO_CRH_MODE9_1; //50 MHz

	/* RX HI-Z input, 10MHz*/
	GPIOA->CRH &= ~GPIO_CRH_CNF10;  //Clear CNF10
	GPIOA->CRH |= GPIO_CRH_CNF10_0; //HI_Z
	GPIOA->CRH &= ~GPIO_CRH_MODE10; //Clear MODE <=> INPUT


	USART1->BRR = 72000000/BaudRate;
	USART1->CR1 |= USART_CR1_UE | USART_CR1_TE | USART_CR1_RE |USART_CR1_RXNEIE|USART_CR1_TCIE;
	NVIC_EnableIRQ(USART1_IRQn);
}
void TxString(char* str)
{
	//enableUart();

	char *p = str;
	int i = 0;

	while(*p)
	{
		Repeat:
		if(USART1->SR && USART_SR_TXE)
		{
			USART1->DR = str[i];
			i++;
			p++;
		}
		else goto Repeat;

	}

}
void initSwdOnlyDebugging()
{
	AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE; // JTAG is disabled
}
int main(void)
{
	enableUart();
	initSwdOnlyDebugging();
	initPortCClock();
	SysTick_Init(72000000);
	clockInit();
	__enable_irq ();

	//    /* Loop forever */
	//	GPIOC->BSRR |= GPIO_BSRR_BS13; // pin C13 initially set
	//	GPIOC->BRR |= GPIO_BRR_BR14; // pin C14 initially reset, GPIOC->BSRR |= GPIO_BSRR_BR14 also works
	//	for(;;)
	//	{
	//		delayMs(500);
	//		GPIOC->ODR^=GPIO_ODR_ODR13;
	//		GPIOC->ODR^=GPIO_ODR_ODR14;
	//
	char str1[] = "Hello World! ";
	TxString(str1);

	char str2[] = "wwwTesting... 0,1,2,3... ";
	TxString(str2);

	strcpy(str1, "sraka\n\r");
	TxString(str1);
}
