/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include "display7segmentmax7219.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint16_t src_buf[128] = {0};
uint16_t dst_buf[128] = {0};
uint32_t full_cnt=0;
uint8_t fl=0;

#define CS1_SET() CLEAR_BIT(GPIOA->ODR,GPIO_ODR_ODR4)
#define CS1_RESET() SET_BIT(GPIOA->ODR,GPIO_ODR_ODR4)
#define SPI1_ENABLE() SET_BIT(SPI1->CR1, SPI_CR1_SPE);
//----------------------------------------------------------
extern "C" void DMA1_Channel2_IRQHandler(void)
{
	if(READ_BIT(DMA1->ISR, DMA_ISR_TCIF2) == (DMA_ISR_TCIF2))
	{
		//Clear Channel 2 global interrupt flag
		WRITE_REG(DMA1->IFCR, DMA_IFCR_CGIF2);
		CS1_RESET();
	}
	else if(READ_BIT(DMA1->ISR, DMA_ISR_TEIF2) == (DMA_ISR_TEIF2))
	{
		__NOP();
	}
}
//----------------------------------------------------------
extern "C" void DMA1_Channel3_IRQHandler(void)
{
	if(READ_BIT(DMA1->ISR, DMA_ISR_TCIF3) == (DMA_ISR_TCIF3))
	{
		//Clear Channel 3 global interrupt flag
		WRITE_REG(DMA1->IFCR, DMA_IFCR_CGIF3);
		fl = 1;
	}
	else if(READ_BIT(DMA1->ISR, DMA_ISR_TEIF3) == (DMA_ISR_TEIF3))
	{
		__NOP();
	}
}


int clockInit(void)

{
	// RCC - reset and clock control, CR - Clock control register
	SET_BIT(RCC->CR, RCC_CR_HSEON); //Enable HSE clock

	while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET); //wait until HSE ready

	//Configuring of PLL (HSE crystal frequency is 8MHz)
	// SYSCLK = 72 МГц, USB = 48 МГц, PCLK1 = 36 МГц, PCLK2 = 72 МГц,  ADC = 12 МГц
	RCC->CFGR |= RCC_CFGR_PLLMULL9 //Bits 21:18, 0111: PLL input clock x 9
			| RCC_CFGR_PLLSRC; //Enable PLL as a source of HSE

	RCC->CR |= RCC_CR_PLLON; //Run PLL

	while(!(RCC->CR & RCC_CR_PLLRDY));
	CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// 2 cycles of Flash wait because 48 MHz < SYSCLK ≤ 72 MHz
	FLASH->ACR &= ~FLASH_ACR_LATENCY_2;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1 //APB2/1
			| RCC_CFGR_PPRE1_DIV2 //APB1/2
			| RCC_CFGR_HPRE_DIV1; //AHB/1

	RCC->CFGR |= RCC_CFGR_SW_PLL;

	while((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_1);

	RCC->CR &= ~RCC_CR_HSION;

	return 0;
}

void spi1_init(void)
{
	GPIOA->CRL &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4 | GPIO_CRL_CNF5 | GPIO_CRL_MODE5 | GPIO_CRL_CNF6 | GPIO_CRL_MODE6 | GPIO_CRL_CNF7 | GPIO_CRL_MODE7);

	GPIOA->CRL   |=  GPIO_CRL_MODE7;  // output 50 MHz
	GPIOA->CRL   &= ~GPIO_CRL_CNF7;	  // Push-Pull
	GPIOA->CRL   |=  GPIO_CRL_CNF7_1; // alternative function push-pull

	GPIOA->CRL   &= ~GPIO_CRL_MODE6;  // Input
	GPIOA->CRL   |=  GPIO_CRL_CNF6_1; // with pull-up / pull-down
	GPIOA->BSRR   =  GPIO_BSRR_BS6;   // Set bit 6 High

	GPIOA->CRL   |=  GPIO_CRL_MODE5;  // output 50 MHz
	GPIOA->CRL   |=  GPIO_CRL_CNF5_1; // alternative function push-pull

	GPIOA->CRL   |=  GPIO_CRL_MODE4;  // output 50 MHz
	GPIOA->CRL   &= ~GPIO_CRL_CNF4;	  // Push-Pull General Purpose
	GPIOA->BSRR   =  GPIO_BSRR_BS4;   // Set bit 4 High

	SPI1->CR1 = 0x0000; // reset SPI configuration registers
	SPI1->CR2 = 0x0000; // reset SPI configuration registers

	RCC->APB2ENR |= RCC_APB2ENR_SPI1EN; // enable spi clock

	CLEAR_BIT(DMA1_Channel2->CCR, DMA_CCR_DIR | DMA_CCR_MEM2MEM); // Set transfer direction (Peripheral to Memory)
	CLEAR_BIT(DMA1_Channel2->CCR, DMA_CCR_PL); // Set priority level


	CLEAR_BIT(DMA1_Channel2->CCR, DMA_CCR_CIRC); //Transfer mode NORMAL
	CLEAR_BIT(DMA1_Channel2->CCR, DMA_CCR_PINC); //Set peripheral no increment mode


	SET_BIT(DMA1_Channel2->CCR, DMA_CCR_MINC); // Set memory increment mode
	MODIFY_REG(DMA1_Channel2->CCR, DMA_CCR_PSIZE_1, DMA_CCR_PSIZE_0); //Set peripheral data width
	MODIFY_REG(DMA1_Channel2->CCR, DMA_CCR_MSIZE_1, DMA_CCR_MSIZE_0); //Set memory data width

	//SPI1_TX Init
	//Set transfer direction (Memory to Peripheral)
	MODIFY_REG(DMA1_Channel3->CCR, DMA_CCR_MEM2MEM, DMA_CCR_DIR);
	//Set priority level
	CLEAR_BIT(DMA1_Channel3->CCR, DMA_CCR_PL);
	//Transfer mode NORMAL
	CLEAR_BIT(DMA1_Channel3->CCR, DMA_CCR_CIRC);
	//Set peripheral no increment mode
	CLEAR_BIT(DMA1_Channel3->CCR, DMA_CCR_PINC);
	//Set memory increment mode
	SET_BIT(DMA1_Channel3->CCR, DMA_CCR_MINC);
	//Set peripheral data width
	MODIFY_REG(DMA1_Channel3->CCR, DMA_CCR_PSIZE_1, DMA_CCR_PSIZE_0);
	//Set memory data width
	MODIFY_REG(DMA1_Channel3->CCR, DMA_CCR_MSIZE_1, DMA_CCR_MSIZE_0);


	SPI1->CR1 = 0 << SPI_CR1_DFF_Pos    // 8 bit Data frame format
			| 0 << SPI_CR1_LSBFIRST_Pos //  MSB transferred first
			| SPI_CR1_SSM               //Software SS
			| SPI_CR1_SSI               // NSS (CS) pin is high
			| SPI_CR1_BR_0 | SPI_CR1_BR_1  //Baud: F_PCLK/16
			| SPI_CR1_MSTR // Master mode
			| 0 << SPI_CR1_CPOL_Pos // Clock polarity
			| 0 << SPI_CR1_CPHA_Pos;  // Clock phase



	SPI1->CR1 |= SPI_CR1_SPE; // Enable SPI

}

void initPortAClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
}

void initPortBClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
}
void initDmaClock()
{
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;
	NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	NVIC_EnableIRQ(DMA1_Channel3_IRQn);
}
void initSwdOnlyDebugging()
{
	AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE; // JTAG is disabled
}
void initAltFunctionsClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
}
int main(void)
{
	clockInit();
	initPortAClock();
	initPortBClock();
	spi1_init();
	initDmaClock();
	initSwdOnlyDebugging();
	initAltFunctionsClock();

	CLEAR_BIT(DMA1_Channel2->CCR, DMA_CCR_EN);
	CLEAR_BIT(DMA1_Channel3->CCR, DMA_CCR_EN);
	WRITE_REG(DMA1->IFCR, DMA_IFCR_CTCIF2);
	//Clear Channel 2 transfer error flag
	WRITE_REG(DMA1->IFCR, DMA_IFCR_CTEIF2);
	//Clear Channel 3 transfer complete flag
	WRITE_REG(DMA1->IFCR, DMA_IFCR_CTCIF3);
	//Clear Channel 3 transfer error flag
	WRITE_REG(DMA1->IFCR, DMA_IFCR_CTEIF3);
	//Enable DMA Tx SPI1
	SET_BIT(SPI1->CR2, SPI_CR2_TXDMAEN);
	//Enable DMA Rx SPI1
	SET_BIT(SPI1->CR2, SPI_CR2_RXDMAEN);
	//Enable Transfer complete interrupt Channel2
	SET_BIT(DMA1_Channel2->CCR, DMA_CCR_TCIE);
	//Enable Transfer error interrupt Channel2
	SET_BIT(DMA1_Channel2->CCR, DMA_CCR_TEIE);
	//Enable Transfer complete interrupt Channel3
	SET_BIT(DMA1_Channel3->CCR, DMA_CCR_TCIE);
	//Enable Transfer error interrupt Channel3
	SET_BIT(DMA1_Channel3->CCR, DMA_CCR_TEIE);
	SPI1_ENABLE();
	for(int i=0;i<128;i++)
	{
		src_buf[i] = full_cnt + i;
	}
	//Disable DMA channels
	CLEAR_BIT(DMA1_Channel2->CCR, DMA_CCR_EN);
	CLEAR_BIT(DMA1_Channel3->CCR, DMA_CCR_EN);
	//Set Number of data to transfer
	MODIFY_REG(DMA1_Channel2->CNDTR, DMA_CNDTR_NDT, 128);
	MODIFY_REG(DMA1_Channel3->CNDTR, DMA_CNDTR_NDT, 128);
	//Configure the Source and Destination addresses
	WRITE_REG(DMA1_Channel2->CPAR, (uint32_t)&(SPI1->DR));
	WRITE_REG(DMA1_Channel2->CMAR, (uint32_t)&dst_buf);
	WRITE_REG(DMA1_Channel3->CPAR, (uint32_t)&(SPI1->DR));
	WRITE_REG(DMA1_Channel3->CMAR, (uint32_t)&src_buf);
	CS1_SET();
	//Enable DMA channels
	SET_BIT(DMA1_Channel3->CCR, DMA_CCR_EN);
	SET_BIT(DMA1_Channel2->CCR, DMA_CCR_EN);
	//while(!fl) {}
	//fl=0;

	Display7segmentMax7219 d(SPI1, GPIOA, 4);
	d.init(15, 8);
	d.print(-82212);
	/* Loop forever */
	for(int i = 0;i < 100;++i)
	{
		d.clean();
		d.print(i);
	}
}
