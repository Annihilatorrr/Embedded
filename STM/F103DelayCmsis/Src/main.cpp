/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

volatile uint32_t sysTick = 0;
extern "C" void SysTick_Handler(void)
{
	if (sysTick > 0)
	{
		--sysTick;
	}
}

void delayMs(uint32_t ms)
{
	sysTick = ms;
	while (sysTick);
}

void SysTick_Init(int cpuFrequency) {
	SysTick->LOAD &= ~SysTick_LOAD_RELOAD_Msk;
	SysTick->LOAD = cpuFrequency/1000-1;
	SysTick->VAL &= ~SysTick_VAL_CURRENT_Msk;
	SysTick->CTRL = (SysTick_CTRL_TICKINT_Msk   |  /* Enable SysTick exception */
			SysTick_CTRL_ENABLE_Msk) |    /* Enable SysTick system timer */
					SysTick_CTRL_CLKSOURCE_Msk;   /* Use processor clock source */

}

void initPortCClock()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

	GPIOC->CRH &= ~GPIO_CRH_CNF13;
	GPIOC->CRH |= GPIO_CRH_MODE13_1;

	GPIOC->CRH &= ~GPIO_CRH_CNF14;
	GPIOC->CRH |= GPIO_CRH_MODE14_1;
}
int clockInit(void)

{
	// RCC - reset and clock control, CR - Clock control register
	SET_BIT(RCC->CR, RCC_CR_HSEON); //Enable HSE clock

	while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET); //wait until HSE ready

	//Configuring of PLL (HSE crystal frequency is 8MHz)
	// SYSCLK = 72 МГц, USB = 48 МГц, PCLK1 = 36 МГц, PCLK2 = 72 МГц,  ADC = 12 МГц
	RCC->CFGR |= RCC_CFGR_PLLMULL9 //Bits 21:18, 0111: PLL input clock x 9
			| RCC_CFGR_PLLSRC; //Enable PLL as a source of HSE

	RCC->CR |= RCC_CR_PLLON; //Run PLL

	while(!(RCC->CR & RCC_CR_PLLRDY));
	CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
	FLASH->ACR |= FLASH_ACR_PRFTBE;

	// 2 cycles of Flash wait because 48 MHz < SYSCLK ≤ 72 MHz
	FLASH->ACR &= ~FLASH_ACR_LATENCY_2;
	FLASH->ACR |= FLASH_ACR_LATENCY_2;

	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1 //APB2/1
			| RCC_CFGR_PPRE1_DIV2 //APB1/2
			| RCC_CFGR_HPRE_DIV1; //AHB/1

	RCC->CFGR |= RCC_CFGR_SW_PLL;

	while((RCC->CFGR & RCC_CFGR_SWS_Msk) != RCC_CFGR_SWS_1);

	RCC->CR &= ~RCC_CR_HSION;

	return 0;
}

int main(void)
{
	initPortCClock();
	SysTick_Init(72000000);
	clockInit();
	__enable_irq ();

    /* Loop forever */
	GPIOC->BSRR |= GPIO_BSRR_BS13; // pin C13 initially set
	GPIOC->BRR |= GPIO_BRR_BR14; // pin C14 initially reset, GPIOC->BSRR |= GPIO_BSRR_BR14 also works
	for(;;)
	{
		delayMs(500);
		GPIOC->ODR^=GPIO_ODR_ODR13;
		GPIOC->ODR^=GPIO_ODR_ODR14;
	}
}
